Ude,Query,AvgElapsedTime,ExecutionCount,MaxElapsedTime,LogCreatedOn,FrequencyPerSec,
<!>queryStatus,idle
<!>queryDuration,0 sec
<!>rowsReturned,10
5,select rtrim(object_name)+' '+rtrim(counter_name) as row; * from master.sys.dm_os_performance_counters where object_name like 'SQLServer:Buffer Manager%',10816,40218,322347,Jun 5 2013 4:51PM,0
1,select rtrim(object_name)+' '+rtrim(counter_name) as row; * from master.sys.dm_os_performance_counters where object_name like 'NYSUPSVR17:Buffer Manager%',7756,1626,243555,Jul 17 2013 1:26PM,0
62,SELECT top 10row_number() over (order by sql_handle) as Ude;t.text as Query;ISNULL(s.total_elapsed_time / s.execution_count; 0) AS AvgElapsedTime;s.execution_count AS ExecutionCount;s.max_elapsed_time AS MaxElapsedTime;s.creation_time AS LogCreatedOn;ISNULL(s.execution_count / DATEDIFF(s; s.creation_time; GETDATE()); 0) AS FrequencyPerSecFROM sys.dm_exec_query_stats s cross apply sys.dm_exec_sql_text( sql_handle ) tORDER BYMaxElapsedTime DESC,15857,40701,480929,Jun 5 2013 4:50PM,0
18,select rtrim(counter_name) as counter_name; cntr_value; cntr_type from master.sys.dm_os_performance_counterswhere object_name like '%Latches%',22904,40702,410297,Jun 5 2013 4:50PM,0
87,select rtrim(instance_name)+' '+rtrim(counter_name) as Variable; rtrim(counter_name) as counter_name; rtrim(instance_name) as instance_name; cntr_value; cntr_type from master.sys.dm_os_performance_counterswhere object_name like '%Locks%',23581,40702,390225,Jun 5 2013 4:50PM,0
100,CREATE PROCEDURE sp_sqlagent_has_server_access  @login_name         sysname = NULL;  @is_sysadmin_member INT     = NULL OUTPUTASBEGIN  DECLARE @has_server_access BIT  DECLARE @is_sysadmin       BIT  DECLARE @actual_login_name sysname  DECLARE @cachedate         DATETIME  SET NOCOUNT ON  SELECT @cachedate = NULL  -- remove expired entries from the cache  DELETE msdb.dbo.syscachedcredentials  WHERE  DATEDIFF(MINUTE; cachedate; GETDATE()) >= 29  -- query the cache  SELECT  @is_sysadmin = is_sysadmin_member;          @has_server_access = has_server_access;          @cachedate = cachedate  FROM    msdb.dbo.syscachedcredentials  WHERE   login_name = @login_name  AND     DATEDIFF(MINUTE; cachedate; GETDATE()) < 29  IF (@cachedate IS NOT NULL)  BEGIN    -- no output variable    IF (@is_sysadmin_member IS NULL)    BEGIN      -- Return result row      SELECT has_server_access = @has_server_access;             is_sysadmin       = @is_sysadmin;             actual_login_name = @login_name      RETURN    END    ELSE    BEGIN      SELECT @is_sysadmin_member = @is_sysadmin      RETURN    END  END -- select from cache  -- Set defaults  SELECT @has_server_access = 0  SELECT @is_sysadmin = 0  SELECT @actual_login_name = FORMATMESSAGE(14205)  IF (@login_name IS NULL)  BEGIN    SELECT has_server_access = 1;           is_sysadmin       = IS_SRVROLEMEMBER(N'sysadmin');           actual_login_name = SUSER_SNAME()    RETURN  END  IF (@login_name LIKE '%\%')  BEGIN    -- Handle the LocalSystem account ('NT AUTHORITY\SYSTEM') as a special case    IF (UPPER(@login_name collate SQL_Latin1_General_CP1_CS_AS) = N'NT AUTHORITY\SYSTEM')    BEGIN      IF (EXISTS (SELECT *                  FROM master.dbo.syslogins                  WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')))      BEGIN        SELECT @has_server_access = hasaccess;               @is_sysadmin = sysadmin;               @actual_login_name = loginname        FROM master.dbo.syslogins        WHERE (UPPER(loginname collate SQL_Latin1_General_CP1_CS_AS) = N'BUILTIN\ADMINISTRATORS')      END    END    ELSE    BEGIN      -- Check if the NT login has been explicitly denied access      IF (EXISTS (SELECT *                  FROM master.dbo.syslogins                  WHERE (loginname = @login_name)                    AND (denylogin = 1)))      BEGIN        SELECT @has_server_access = 0;               @is_sysadmin = sysadmin;               @actual_login_name = loginname        FROM master.dbo.syslogins        WHERE (loginname = @login_name)      END      ELSE      BEGIN        -- declare table variable for storing results        DECLARE @xp_results TABLE        (        account_name      sysname      COLLATE database_default NOT NULL PRIMARY KEY;        type              NVARCHAR(10) COLLATE database_default NOT NULL;        privilege         NVARCHAR(10) COLLATE database_default NOT NULL;        mapped_login_name sysname      COLLATE database_default NOT NULL;        permission_path   sysname      COLLATE database_default NULL        )        -- Call xp_logininfo to determine server access        INSERT INTO @xp_results        EXECUTE master.dbo.xp_logininfo @login_name        SELECT @has_server_access = CASE COUNT(*)                                      WHEN 0 THEN 0                                      ELSE 1                                    END        FROM @xp_results        SELECT @actual_login_name = mapped_login_name;               @is_sysadmin = CASE UPPER(privilege collate SQL_Latin1_General_CP1_CS_AS)                                WHEN 'ADMIN' THEN 1                                ELSE 0                             END        FROM @xp_results      END    END  END  ELSE  BEGIN    -- Standard login    IF (EXISTS (SELECT *                FROM master.dbo.syslogins                WHERE (loginname = @login_name)))    BEGIN      SELECT @has_server_access = hasaccess;             @is_sysadmin = sysadmin;             @actual_login_name = loginname      FROM master.dbo.syslogins      WHERE (loginname = @login_name)    END  END  -- update the cache only if something is found  IF  (UPPER(@actual_login_name collate SQL_Latin1_General_CP1_CS_AS) <> '(UNKNOWN)')  BEGIN    DECLARE @TranCounter INT;    SET @TranCounter = @@TRANCOUNT;    IF @TranCounter > 0    BEGIN        -- Procedure called when there is        -- an active transaction.        -- Create a savepoint to be able        -- to roll back only the work done        -- in the procedure if there is an        -- error.        SAVE TRANSACTION tran_sp_has_server_access;    END    ELSE    BEGIN        -- Procedure must start its own        -- transaction.        BEGIN TRANSACTION;    END    -- Modify database.    --use a try catch login to prevent any error when trying to insert/update syscachedcredentials table    --no need to fail since the job owner has been validated    BEGIN TRY            IF EXISTS (SELECT * FROM msdb.dbo.syscachedcredentials WITH (TABLOCKX) WHERE login_name = @login_name)      BEGIN        UPDATE msdb.dbo.syscachedcredentials        SET    has_server_access = @has_server_access;              is_sysadmin_member = @is_sysadmin;              cachedate = GETDATE()        WHERE  login_name = @login_name      END      ELSE      BEGIN        INSERT INTO msdb.dbo.syscachedcredentials(login_name; has_server_access; is_sysadmin_member)         VALUES(@login_name; @has_server_access; @is_sysadmin)      END      IF @TranCounter = 0      BEGIN          -- @TranCounter = 0 means no transaction was          -- started before the procedure was called.          -- The procedure must commit the transaction          -- it started.          COMMIT TRANSACTION;        END   END TRY  BEGIN CATCH      -- An error occurred; must determine      -- which type of rollback will roll      -- back only the work done in the      -- procedure.      IF @TranCounter = 0      BEGIN          -- Transaction started in procedure.          -- Roll back complete transaction.          ROLLBACK TRANSACTION;      END      ELSE          -- Transaction started before procedure          -- called; do not roll back modifications          -- made before the procedure was called.          IF (XACT_STATE()) <> - 1          BEGIN              -- If the transaction is still valid; just              -- roll back to the savepoint set at the              -- start of the stored procedure.              ROLLBACK TRANSACTION tran_sp_has_server_access;          END          -- If the transaction is uncommitable; a rollback          -- to the save point is not allowed because          -- the savepoint rollback writes to the log.          -- Just do nothing since it is not critical to update syscredential table    END CATCH   END  IF (@is_sysadmin_member IS NULL)    -- Return result row    SELECT has_server_access = @has_server_access;           is_sysadmin       = @is_sysadmin;           actual_login_name = @actual_login_name  ELSE    -- output variable only    SELECT @is_sysadmin_member = @is_sysadminEND,58636,8,348359,Jun 5 2013 4:49PM,0
80,select * from master.sys.dm_os_performance_counters where object_name like 'Buffer Manager%',17486,484,270054,Jun 5 2013 4:50PM,0
73,SELECT     B.name as Database_Name; ISNULL(STR(ABS(DATEDIFF(day; GetDate();     MAX(Backup_finish_date)))); 'NEVER') as DaysSinceLastBackup;    ISNULL(Convert(char(10); MAX(backup_finish_date); 101); 'NEVER') as LastBackupDateFROM master.dbo.sysdatabases B LEFT OUTER JOIN msdb.dbo.backupset A ON A.database_name = B.name AND A.type = 'D' GROUP BY B.Name ORDER BY B.name,155,616929,246438,Jun 5 2013 4:50PM,0
88,select rtrim(instance_name)+' '+rtrim(counter_name) as Variable; rtrim(counter_name) as counter_name; rtrim(instance_name) as instance_name; cntr_value; cntr_type from master.sys.dm_os_performance_counterswhere object_name like '%Locks%',18425,1626,225238,Jul 17 2013 1:26PM,0
17,select rtrim(counter_name) as counter_name; cntr_value; cntr_type from master.sys.dm_os_performance_counterswhere object_name like '%Latches%',20455,1626,207720,Jul 17 2013 1:26PM,0